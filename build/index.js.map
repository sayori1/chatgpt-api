{"version":3,"sources":["../src/chatgpt-api.ts","../src/types.ts","../src/abstract-chatgpt-api.ts","../src/fetch.ts","../src/fetch-sse.ts","../src/stream-async-iterable.ts","../src/utils.ts","../src/chatgpt-api-browser.ts","../src/openai-auth.ts"],"sourcesContent":["import ExpiryMap from 'expiry-map'\r\nimport pTimeout from 'p-timeout'\r\nimport { v4 as uuidv4 } from 'uuid'\r\n\r\nimport * as types from './types'\r\nimport { AChatGPTAPI } from './abstract-chatgpt-api'\r\nimport { fetch } from './fetch'\r\nimport { fetchSSE } from './fetch-sse'\r\nimport { markdownToText } from './utils'\r\n\r\nconst KEY_ACCESS_TOKEN = 'accessToken'\r\nconst USER_AGENT =\r\n  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'\r\n\r\nexport class ChatGPTAPI extends AChatGPTAPI {\r\n  protected _sessionToken: string\r\n  protected _clearanceToken: string\r\n  protected _markdown: boolean\r\n  protected _debug: boolean\r\n  protected _apiBaseUrl: string\r\n  protected _backendApiBaseUrl: string\r\n  protected _userAgent: string\r\n  protected _headers: Record<string, string>\r\n  protected _user: types.User | null = null\r\n\r\n  // Stores access tokens for `accessTokenTTL` milliseconds before needing to refresh\r\n  protected _accessTokenCache: ExpiryMap<string, string>\r\n\r\n  /**\r\n   * Creates a new client wrapper around the unofficial ChatGPT REST API.\r\n   *\r\n   * Note that your IP address and `userAgent` must match the same values that you used\r\n   * to obtain your `clearanceToken`.\r\n   *\r\n   * @param opts.sessionToken = **Required** OpenAI session token which can be found in a valid session's cookies (see readme for instructions)\r\n   * @param opts.clearanceToken = **Required** Cloudflare `cf_clearance` cookie value (see readme for instructions)\r\n   * @param apiBaseUrl - Optional override; the base URL for ChatGPT webapp's API (`/api`)\r\n   * @param backendApiBaseUrl - Optional override; the base URL for the ChatGPT backend API (`/backend-api`)\r\n   * @param userAgent - Optional override; the `user-agent` header to use with ChatGPT requests\r\n   * @param accessTokenTTL - Optional override; how long in milliseconds access tokens should last before being forcefully refreshed\r\n   * @param accessToken - Optional default access token if you already have a valid one generated\r\n   * @param heaaders - Optional additional HTTP headers to be added to each `fetch` request\r\n   * @param debug - Optional enables logging debugging into to stdout\r\n   */\r\n  constructor(opts: {\r\n    sessionToken: string\r\n\r\n    clearanceToken: string\r\n\r\n    /** @defaultValue `true` **/\r\n    markdown?: boolean\r\n\r\n    /** @defaultValue `'https://chat.openai.com/api'` **/\r\n    apiBaseUrl?: string\r\n\r\n    /** @defaultValue `'https://chat.openai.com/backend-api'` **/\r\n    backendApiBaseUrl?: string\r\n\r\n    /** @defaultValue `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'` **/\r\n    userAgent?: string\r\n\r\n    /** @defaultValue 1 hour **/\r\n    accessTokenTTL?: number\r\n\r\n    /** @defaultValue `undefined` **/\r\n    accessToken?: string\r\n\r\n    /** @defaultValue `undefined` **/\r\n    headers?: Record<string, string>\r\n\r\n    /** @defaultValue `false` **/\r\n    debug?: boolean\r\n  }) {\r\n    super()\r\n\r\n    const {\r\n      sessionToken,\r\n      clearanceToken,\r\n      markdown = true,\r\n      apiBaseUrl = 'https://chat.openai.com/api',\r\n      backendApiBaseUrl = 'https://chat.openai.com/backend-api',\r\n      userAgent = USER_AGENT,\r\n      accessTokenTTL = 60 * 60000, // 1 hour\r\n      accessToken,\r\n      headers,\r\n      debug = false\r\n    } = opts\r\n\r\n    this._sessionToken = sessionToken\r\n    this._clearanceToken = clearanceToken\r\n    this._markdown = !!markdown\r\n    this._debug = !!debug\r\n    this._apiBaseUrl = apiBaseUrl\r\n    this._backendApiBaseUrl = backendApiBaseUrl\r\n    this._userAgent = userAgent\r\n    this._headers = {\r\n      'user-agent': this._userAgent,\r\n      'x-openai-assistant-app-id': '',\r\n      'accept-language': 'en-US,en;q=0.9',\r\n      'accept-encoding': 'gzip, deflate, br',\r\n      origin: 'https://chat.openai.com',\r\n      referer: 'https://chat.openai.com/chat',\r\n      'sec-ch-ua':\r\n        '\"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"108\", \"Google Chrome\";v=\"108\"',\r\n      'sec-ch-ua-platform': '\"macOS\"',\r\n      'sec-fetch-dest': 'empty',\r\n      'sec-fetch-mode': 'cors',\r\n      'sec-fetch-site': 'same-origin',\r\n      ...headers\r\n    }\r\n\r\n    this._accessTokenCache = new ExpiryMap<string, string>(accessTokenTTL)\r\n    if (accessToken) {\r\n      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken)\r\n    }\r\n\r\n    if (!this._sessionToken) {\r\n      const error = new types.ChatGPTError('ChatGPT invalid session token')\r\n      error.statusCode = 401\r\n      throw error\r\n    }\r\n\r\n    if (!this._clearanceToken) {\r\n      const error = new types.ChatGPTError('ChatGPT invalid clearance token')\r\n      error.statusCode = 401\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the currently signed-in user, if authenticated, `null` otherwise.\r\n   */\r\n  get user() {\r\n    return this._user\r\n  }\r\n\r\n  /** Gets the current session token. */\r\n  get sessionToken() {\r\n    return this._sessionToken\r\n  }\r\n\r\n  /** Gets the current Cloudflare clearance token (`cf_clearance` cookie value). */\r\n  get clearanceToken() {\r\n    return this._clearanceToken\r\n  }\r\n\r\n  /** Gets the current user agent. */\r\n  get userAgent() {\r\n    return this._userAgent\r\n  }\r\n\r\n  /**\r\n   * Refreshes the client's access token which will succeed only if the session\r\n   * is valid.\r\n   */\r\n  override async initSession() {\r\n    await this.refreshSession()\r\n  }\r\n\r\n  /**\r\n   * Sends a message to ChatGPT, waits for the response to resolve, and returns\r\n   * the response.\r\n   *\r\n   * If you want to receive a stream of partial responses, use `opts.onProgress`.\r\n   * If you want to receive the full response, including message and conversation IDs,\r\n   * you can use `opts.onConversationResponse` or use the `ChatGPTAPI.getConversation`\r\n   * helper.\r\n   *\r\n   * @param message - The prompt message to send\r\n   * @param opts.conversationId - Optional ID of a conversation to continue\r\n   * @param opts.parentMessageId - Optional ID of the previous message in the conversation\r\n   * @param opts.messageId - Optional ID of the message to send (defaults to a random UUID)\r\n   * @param opts.action - Optional ChatGPT `action` (either `next` or `variant`)\r\n   * @param opts.timeoutMs - Optional timeout in milliseconds (defaults to no timeout)\r\n   * @param opts.onProgress - Optional callback which will be invoked every time the partial response is updated\r\n   * @param opts.abortSignal - Optional callback used to abort the underlying `fetch` call using an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\r\n   *\r\n   * @returns The response from ChatGPT\r\n   */\r\n  override async sendMessage(\r\n    message: string,\r\n    opts: types.SendMessageOptions = {}\r\n  ): Promise<types.ChatResponse> {\r\n    const {\r\n      conversationId,\r\n      parentMessageId = uuidv4(),\r\n      messageId = uuidv4(),\r\n      action = 'next',\r\n      timeoutMs,\r\n      onProgress\r\n    } = opts\r\n\r\n    let { abortSignal } = opts\r\n\r\n    let abortController: AbortController = null\r\n    if (timeoutMs && !abortSignal) {\r\n      abortController = new AbortController()\r\n      abortSignal = abortController.signal\r\n    }\r\n\r\n    const accessToken = await this.refreshSession()\r\n\r\n    const body: types.ConversationJSONBody = {\r\n      action,\r\n      messages: [\r\n        {\r\n          id: messageId,\r\n          role: 'user',\r\n          content: {\r\n            content_type: 'text',\r\n            parts: [message]\r\n          }\r\n        }\r\n      ],\r\n      model: 'text-davinci-002-render',\r\n      parent_message_id: parentMessageId\r\n    }\r\n\r\n    if (conversationId) {\r\n      body.conversation_id = conversationId\r\n    }\r\n\r\n    const result: types.ChatResponse = {\r\n      conversationId,\r\n      messageId,\r\n      response: ''\r\n    }\r\n\r\n    const responseP = new Promise<types.ChatResponse>((resolve, reject) => {\r\n      const url = `${this._backendApiBaseUrl}/conversation`\r\n      const headers = {\r\n        ...this._headers,\r\n        Authorization: `Bearer ${accessToken}`,\r\n        Accept: 'text/event-stream',\r\n        'Content-Type': 'application/json',\r\n        Cookie: `cf_clearance=${this._clearanceToken}`\r\n      }\r\n\r\n      if (this._debug) {\r\n        console.log('POST', url, { body, headers })\r\n      }\r\n\r\n      fetchSSE(url, {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body),\r\n        signal: abortSignal,\r\n        onMessage: (data: string) => {\r\n          if (data === '[DONE]') {\r\n            return resolve(result)\r\n          }\r\n\r\n          try {\r\n            const convoResponseEvent: types.ConversationResponseEvent =\r\n              JSON.parse(data)\r\n            if (convoResponseEvent.conversation_id) {\r\n              result.conversationId = convoResponseEvent.conversation_id\r\n            }\r\n\r\n            if (convoResponseEvent.message?.id) {\r\n              result.messageId = convoResponseEvent.message.id\r\n            }\r\n\r\n            const message = convoResponseEvent.message\r\n            // console.log('event', JSON.stringify(convoResponseEvent, null, 2))\r\n\r\n            if (message) {\r\n              let text = message?.content?.parts?.[0]\r\n\r\n              if (text) {\r\n                if (!this._markdown) {\r\n                  text = markdownToText(text)\r\n                }\r\n\r\n                result.response = text\r\n\r\n                if (onProgress) {\r\n                  onProgress(result)\r\n                }\r\n              }\r\n            }\r\n          } catch (err) {\r\n            console.warn('fetchSSE onMessage unexpected error', err)\r\n            reject(err)\r\n          }\r\n        }\r\n      }).catch((err) => {\r\n        const errMessageL = err.toString().toLowerCase()\r\n\r\n        if (\r\n          result.response &&\r\n          (errMessageL === 'error: typeerror: terminated' ||\r\n            errMessageL === 'typeerror: terminated')\r\n        ) {\r\n          // OpenAI sometimes forcefully terminates the socket from their end before\r\n          // the HTTP request has resolved cleanly. In my testing, these cases tend to\r\n          // happen when OpenAI has already send the last `response`, so we can ignore\r\n          // the `fetch` error in this case.\r\n          return resolve(result)\r\n        } else {\r\n          return reject(err)\r\n        }\r\n      })\r\n    })\r\n\r\n    if (timeoutMs) {\r\n      if (abortController) {\r\n        // This will be called when a timeout occurs in order for us to forcibly\r\n        // ensure that the underlying HTTP request is aborted.\r\n        ;(responseP as any).cancel = () => {\r\n          abortController.abort()\r\n        }\r\n      }\r\n\r\n      return pTimeout(responseP, {\r\n        milliseconds: timeoutMs,\r\n        message: 'ChatGPT timed out waiting for response'\r\n      })\r\n    } else {\r\n      return responseP\r\n    }\r\n  }\r\n\r\n  async sendModeration(input: string) {\r\n    const accessToken = await this.refreshSession()\r\n    const url = `${this._backendApiBaseUrl}/moderations`\r\n    const headers = {\r\n      ...this._headers,\r\n      Authorization: `Bearer ${accessToken}`,\r\n      Accept: '*/*',\r\n      'Content-Type': 'application/json',\r\n      Cookie: `cf_clearance=${this._clearanceToken}`\r\n    }\r\n\r\n    const body: types.ModerationsJSONBody = {\r\n      input,\r\n      model: 'text-moderation-playground'\r\n    }\r\n\r\n    if (this._debug) {\r\n      console.log('POST', url, headers, body)\r\n    }\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers,\r\n      body: JSON.stringify(body)\r\n    }).then((r) => {\r\n      if (!r.ok) {\r\n        const error = new types.ChatGPTError(`${r.status} ${r.statusText}`)\r\n        error.response = r\r\n        error.statusCode = r.status\r\n        error.statusText = r.statusText\r\n        throw error\r\n      }\r\n\r\n      return r.json() as any as types.ModerationsJSONResult\r\n    })\r\n\r\n    return res\r\n  }\r\n\r\n  /**\r\n   * @returns `true` if the client has a valid acces token or `false` if refreshing\r\n   * the token fails.\r\n   */\r\n  override async getIsAuthenticated() {\r\n    try {\r\n      void (await this.refreshSession())\r\n      return true\r\n    } catch (err) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempts to refresh the current access token using the ChatGPT\r\n   * `sessionToken` cookie.\r\n   *\r\n   * Access tokens will be cached for up to `accessTokenTTL` milliseconds to\r\n   * prevent refreshing access tokens too frequently.\r\n   *\r\n   * @returns A valid access token\r\n   * @throws An error if refreshing the access token fails.\r\n   */\r\n  override async refreshSession(): Promise<string> {\r\n    const cachedAccessToken = this._accessTokenCache.get(KEY_ACCESS_TOKEN)\r\n    if (cachedAccessToken) {\r\n      return cachedAccessToken\r\n    }\r\n\r\n    let response: Response\r\n    try {\r\n      const url = `${this._apiBaseUrl}/auth/session`\r\n      const headers = {\r\n        ...this._headers,\r\n        cookie: `cf_clearance=${this._clearanceToken}; __Secure-next-auth.session-token=${this._sessionToken}`,\r\n        accept: '*/*'\r\n      }\r\n\r\n      if (this._debug) {\r\n        console.log('GET', url, headers)\r\n      }\r\n\r\n      const res = await fetch(url, {\r\n        headers\r\n      }).then((r) => {\r\n        response = r\r\n\r\n        if (!r.ok) {\r\n          const error = new types.ChatGPTError(`${r.status} ${r.statusText}`)\r\n          error.response = r\r\n          error.statusCode = r.status\r\n          error.statusText = r.statusText\r\n          throw error\r\n        }\r\n\r\n        return r.json() as any as types.SessionResult\r\n      })\r\n\r\n      const accessToken = res?.accessToken\r\n\r\n      if (!accessToken) {\r\n        const error = new types.ChatGPTError('Unauthorized')\r\n        error.response = response\r\n        error.statusCode = response?.status\r\n        error.statusText = response?.statusText\r\n        throw error\r\n      }\r\n\r\n      const appError = res?.error\r\n      if (appError) {\r\n        if (appError === 'RefreshAccessTokenError') {\r\n          const error = new types.ChatGPTError('session token may have expired')\r\n          error.response = response\r\n          error.statusCode = response?.status\r\n          error.statusText = response?.statusText\r\n          throw error\r\n        } else {\r\n          const error = new types.ChatGPTError(appError)\r\n          error.response = response\r\n          error.statusCode = response?.status\r\n          error.statusText = response?.statusText\r\n          throw error\r\n        }\r\n      }\r\n\r\n      if (res.user) {\r\n        this._user = res.user\r\n      }\r\n\r\n      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken)\r\n      return accessToken\r\n    } catch (err: any) {\r\n      if (this._debug) {\r\n        console.error(err)\r\n      }\r\n\r\n      const error = new types.ChatGPTError(\r\n        `ChatGPT failed to refresh auth token. ${err.toString()}`\r\n      )\r\n      error.response = response\r\n      error.statusCode = response?.status\r\n      error.statusText = response?.statusText\r\n      error.originalError = err\r\n      throw error\r\n    }\r\n  }\r\n\r\n  override async closeSession(): Promise<void> {\r\n    this._accessTokenCache.delete(KEY_ACCESS_TOKEN)\r\n  }\r\n}\r\n","export type ContentType = 'text'\r\n\r\nexport type Role = 'user' | 'assistant'\r\n\r\n/**\r\n * https://chat.openapi.com/api/auth/session\r\n */\r\nexport type SessionResult = {\r\n  /**\r\n   * Authenticated user\r\n   */\r\n  user: User\r\n\r\n  /**\r\n   * ISO date of the expiration date of the access token\r\n   */\r\n  expires: string\r\n\r\n  /**\r\n   * The access token\r\n   */\r\n  accessToken: string\r\n\r\n  /**\r\n   * If there was an error associated with this request\r\n   */\r\n  error?: string | null\r\n}\r\n\r\nexport type User = {\r\n  /**\r\n   * ID of the user\r\n   */\r\n  id: string\r\n\r\n  /**\r\n   * Name of the user\r\n   */\r\n  name: string\r\n\r\n  /**\r\n   * Email of the user\r\n   */\r\n  email?: string\r\n\r\n  /**\r\n   * Image of the user\r\n   */\r\n  image: string\r\n\r\n  /**\r\n   * Picture of the user\r\n   */\r\n  picture: string\r\n\r\n  /**\r\n   * Groups the user is in\r\n   */\r\n  groups: string[]\r\n\r\n  /**\r\n   * Features the user is in\r\n   */\r\n  features: string[]\r\n}\r\n\r\n/**\r\n * https://chat.openapi.com/backend-api/models\r\n */\r\nexport type ModelsResult = {\r\n  /**\r\n   * Array of models\r\n   */\r\n  models: Model[]\r\n}\r\n\r\nexport type Model = {\r\n  /**\r\n   * Name of the model\r\n   */\r\n  slug: string\r\n\r\n  /**\r\n   * Max tokens of the model\r\n   */\r\n  max_tokens: number\r\n\r\n  /**\r\n   * Whether or not the model is special\r\n   */\r\n  is_special: boolean\r\n}\r\n\r\n/**\r\n * https://chat.openapi.com/backend-api/moderations\r\n */\r\nexport type ModerationsJSONBody = {\r\n  /**\r\n   * Input for the moderation decision\r\n   */\r\n  input: string\r\n\r\n  /**\r\n   * The model to use in the decision\r\n   */\r\n  model: AvailableModerationModels\r\n}\r\n\r\nexport type AvailableModerationModels = 'text-moderation-playground'\r\n\r\n/**\r\n * https://chat.openapi.com/backend-api/moderations\r\n */\r\nexport type ModerationsJSONResult = {\r\n  /**\r\n   * Whether or not the input is flagged\r\n   */\r\n  flagged: boolean\r\n\r\n  /**\r\n   * Whether or not the input is blocked\r\n   */\r\n  blocked: boolean\r\n\r\n  /**\r\n   * The ID of the decision\r\n   */\r\n  moderation_id: string\r\n}\r\n\r\n/**\r\n * https://chat.openapi.com/backend-api/conversation\r\n */\r\nexport type ConversationJSONBody = {\r\n  /**\r\n   * The action to take\r\n   */\r\n  action: string\r\n\r\n  /**\r\n   * The ID of the conversation\r\n   */\r\n  conversation_id?: string\r\n\r\n  /**\r\n   * Prompts to provide\r\n   */\r\n  messages: Prompt[]\r\n\r\n  /**\r\n   * The model to use\r\n   */\r\n  model: string\r\n\r\n  /**\r\n   * The parent message ID\r\n   */\r\n  parent_message_id: string\r\n}\r\n\r\nexport type Prompt = {\r\n  /**\r\n   * The content of the prompt\r\n   */\r\n  content: PromptContent\r\n\r\n  /**\r\n   * The ID of the prompt\r\n   */\r\n  id: string\r\n\r\n  /**\r\n   * The role played in the prompt\r\n   */\r\n  role: Role\r\n}\r\n\r\nexport type PromptContent = {\r\n  /**\r\n   * The content type of the prompt\r\n   */\r\n  content_type: ContentType\r\n\r\n  /**\r\n   * The parts to the prompt\r\n   */\r\n  parts: string[]\r\n}\r\n\r\n/**\r\n * https://chat.openapi.com/backend-api/conversation/message_feedback\r\n */\r\nexport type MessageFeedbackJSONBody = {\r\n  /**\r\n   * The ID of the conversation\r\n   */\r\n  conversation_id: string\r\n\r\n  /**\r\n   * The message ID\r\n   */\r\n  message_id: string\r\n\r\n  /**\r\n   * The rating\r\n   */\r\n  rating: MessageFeedbackRating\r\n\r\n  /**\r\n   * Tags to give the rating\r\n   */\r\n  tags?: MessageFeedbackTags[]\r\n\r\n  /**\r\n   * The text to include\r\n   */\r\n  text?: string\r\n}\r\n\r\nexport type MessageFeedbackTags = 'harmful' | 'false' | 'not-helpful'\r\n\r\nexport type MessageFeedbackResult = {\r\n  /**\r\n   * The message ID\r\n   */\r\n  message_id: string\r\n\r\n  /**\r\n   * The ID of the conversation\r\n   */\r\n  conversation_id: string\r\n\r\n  /**\r\n   * The ID of the user\r\n   */\r\n  user_id: string\r\n\r\n  /**\r\n   * The rating\r\n   */\r\n  rating: MessageFeedbackRating\r\n\r\n  /**\r\n   * The text the server received, including tags\r\n   */\r\n  text?: string\r\n}\r\n\r\nexport type MessageFeedbackRating = 'thumbsUp' | 'thumbsDown'\r\n\r\nexport type ConversationResponseEvent = {\r\n  message?: Message\r\n  conversation_id?: string\r\n  error?: string | null\r\n}\r\n\r\nexport type Message = {\r\n  id: string\r\n  content: MessageContent\r\n  role: string\r\n  user: string | null\r\n  create_time: string | null\r\n  update_time: string | null\r\n  end_turn: null\r\n  weight: number\r\n  recipient: string\r\n  metadata: MessageMetadata\r\n}\r\n\r\nexport type MessageContent = {\r\n  content_type: string\r\n  parts: string[]\r\n}\r\n\r\nexport type MessageMetadata = any\r\nexport type MessageActionType = 'next' | 'variant'\r\n\r\nexport type SendMessageOptions = {\r\n  conversationId?: string\r\n  parentMessageId?: string\r\n  messageId?: string\r\n  action?: MessageActionType\r\n  timeoutMs?: number\r\n  onProgress?: (partialResponse: ChatResponse) => void\r\n  abortSignal?: AbortSignal\r\n}\r\n\r\nexport type SendConversationMessageOptions = Omit<\r\n  SendMessageOptions,\r\n  'conversationId' | 'parentMessageId'\r\n>\r\n\r\nexport class ChatGPTError extends Error {\r\n  statusCode?: number\r\n  statusText?: string\r\n  response?: Response\r\n  originalError?: Error\r\n}\r\n\r\nexport type ChatError = {\r\n  error: { message: string; statusCode?: number; statusText?: string }\r\n  conversationId?: string\r\n  messageId?: string\r\n}\r\n\r\nexport type ChatResponse = {\r\n  response: string\r\n  conversationId: string\r\n  messageId: string\r\n}\r\n","import * as types from './types'\r\n\r\nexport abstract class AChatGPTAPI {\r\n  /**\r\n   * Performs any async initialization work required to ensure that this API is\r\n   * properly authenticated.\r\n   *\r\n   * @throws An error if the session failed to initialize properly.\r\n   */\r\n  abstract initSession(): Promise<void>\r\n\r\n  /**\r\n   * Sends a message to ChatGPT, waits for the response to resolve, and returns\r\n   * the response.\r\n   *\r\n   * If you want to receive a stream of partial responses, use `opts.onProgress`.\r\n   *\r\n   * @param message - The prompt message to send\r\n   * @param opts.conversationId - Optional ID of a conversation to continue\r\n   * @param opts.parentMessageId - Optional ID of the previous message in the conversation\r\n   * @param opts.messageId - Optional ID of the message to send (defaults to a random UUID)\r\n   * @param opts.action - Optional ChatGPT `action` (either `next` or `variant`)\r\n   * @param opts.timeoutMs - Optional timeout in milliseconds (defaults to no timeout)\r\n   * @param opts.onProgress - Optional callback which will be invoked every time the partial response is updated\r\n   * @param opts.abortSignal - Optional callback used to abort the underlying `fetch` call using an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\r\n   *\r\n   * @returns The response from ChatGPT, including `conversationId`, `messageId`, and\r\n   * the `response` text.\r\n   */\r\n  abstract sendMessage(\r\n    message: string,\r\n    opts?: types.SendMessageOptions\r\n  ): Promise<types.ChatResponse>\r\n\r\n  /**\r\n   * @returns `true` if the client is authenticated with a valid session or `false`\r\n   * otherwise.\r\n   */\r\n  abstract getIsAuthenticated(): Promise<boolean>\r\n\r\n  /**\r\n   * Refreshes the current ChatGPT session.\r\n   *\r\n   * Useful for bypassing 403 errors when Cloudflare clearance tokens expire.\r\n   *\r\n   * @returns Access credentials for the new session.\r\n   * @throws An error if it fails.\r\n   */\r\n  abstract refreshSession(): Promise<any>\r\n\r\n  /**\r\n   * Closes the current ChatGPT session and starts a new one.\r\n   *\r\n   * Useful for bypassing 401 errors when sessions expire.\r\n   *\r\n   * @returns Access credentials for the new session.\r\n   * @throws An error if it fails.\r\n   */\r\n  async resetSession(): Promise<any> {\r\n    await this.closeSession()\r\n    return this.initSession()\r\n  }\r\n\r\n  /**\r\n   * Closes the active session.\r\n   *\r\n   * @throws An error if it fails.\r\n   */\r\n  abstract closeSession(): Promise<void>\r\n}\r\n","/// <reference lib=\"dom\" />\r\n\r\n// Use `fetch` for node.js >= 18\r\n// Use `fetch` for all other environments, including browsers\r\nconst fetch = globalThis.fetch\r\n\r\nif (typeof fetch !== 'function') {\r\n  throw new Error(\r\n    'Invalid environment: global fetch not defined; `chatgpt` requires Node.js >= 18 at the moment due to Cloudflare protections'\r\n  )\r\n}\r\n\r\nexport { fetch }\r\n","import { createParser } from 'eventsource-parser'\r\n\r\nimport * as types from './types'\r\nimport { fetch } from './fetch'\r\nimport { streamAsyncIterable } from './stream-async-iterable'\r\n\r\nexport async function fetchSSE(\r\n  url: string,\r\n  options: Parameters<typeof fetch>[1] & { onMessage: (data: string) => void }\r\n) {\r\n  const { onMessage, ...fetchOptions } = options\r\n  const res = await fetch(url, fetchOptions)\r\n  if (!res.ok) {\r\n    const msg = `ChatGPTAPI error ${res.status || res.statusText}`\r\n    const error = new types.ChatGPTError(msg)\r\n    error.statusCode = res.status\r\n    error.statusText = res.statusText\r\n    error.response = res\r\n    throw error\r\n  }\r\n\r\n  const parser = createParser((event) => {\r\n    if (event.type === 'event') {\r\n      onMessage(event.data)\r\n    }\r\n  })\r\n\r\n  if (!res.body.getReader) {\r\n    // Vercel polyfills `fetch` with `node-fetch`, which doesn't conform to\r\n    // web standards, so this is a workaround...\r\n    const body: NodeJS.ReadableStream = res.body as any\r\n\r\n    if (!body.on || !body.read) {\r\n      throw new types.ChatGPTError('unsupported \"fetch\" implementation')\r\n    }\r\n\r\n    body.on('readable', () => {\r\n      let chunk: string | Buffer\r\n      while (null !== (chunk = body.read())) {\r\n        parser.feed(chunk.toString())\r\n      }\r\n    })\r\n  } else {\r\n    for await (const chunk of streamAsyncIterable(res.body)) {\r\n      const str = new TextDecoder().decode(chunk)\r\n      parser.feed(str)\r\n    }\r\n  }\r\n}\r\n","export async function* streamAsyncIterable<T>(stream: ReadableStream<T>) {\r\n  const reader = stream.getReader()\r\n  try {\r\n    while (true) {\r\n      const { done, value } = await reader.read()\r\n      if (done) {\r\n        return\r\n      }\r\n      yield value\r\n    }\r\n  } finally {\r\n    reader.releaseLock()\r\n  }\r\n}\r\n","import type * as PTimeoutTypes from 'p-timeout'\r\nimport type {\r\n  EventSourceParseCallback,\r\n  EventSourceParser\r\n} from 'eventsource-parser'\r\nimport type { Page } from 'puppeteer'\r\nimport { remark } from 'remark'\r\nimport stripMarkdown from 'strip-markdown'\r\n\r\nimport * as types from './types'\r\n\r\nexport function markdownToText(markdown?: string): string {\r\n  return remark()\r\n    .use(stripMarkdown)\r\n    .processSync(markdown ?? '')\r\n    .toString()\r\n}\r\n\r\nexport async function minimizePage(page: Page) {\r\n  const session = await page.target().createCDPSession()\r\n  const goods = await session.send('Browser.getWindowForTarget')\r\n  const { windowId } = goods\r\n  await session.send('Browser.setWindowBounds', {\r\n    windowId,\r\n    bounds: { windowState: 'minimized' }\r\n  })\r\n}\r\n\r\nexport async function maximizePage(page: Page) {\r\n  const session = await page.target().createCDPSession()\r\n  const goods = await session.send('Browser.getWindowForTarget')\r\n  const { windowId } = goods\r\n  await session.send('Browser.setWindowBounds', {\r\n    windowId,\r\n    bounds: { windowState: 'normal' }\r\n  })\r\n}\r\n\r\nexport function isRelevantRequest(url: string): boolean {\r\n  let pathname: string\r\n\r\n  try {\r\n    const parsedUrl = new URL(url)\r\n    pathname = parsedUrl.pathname\r\n    url = parsedUrl.toString()\r\n  } catch (_) {\r\n    return false\r\n  }\r\n\r\n  if (!url.startsWith('https://chat.openai.com')) {\r\n    return false\r\n  }\r\n\r\n  if (\r\n    !pathname.startsWith('/backend-api/') &&\r\n    !pathname.startsWith('/api/auth/session')\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  if (pathname.endsWith('backend-api/moderations')) {\r\n    return false\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * This function is injected into the ChatGPT webapp page using puppeteer. It\r\n * has to be fully self-contained, so we copied a few third-party sources and\r\n * included them in here.\r\n */\r\nexport async function browserPostEventStream(\r\n  url: string,\r\n  accessToken: string,\r\n  body: types.ConversationJSONBody,\r\n  timeoutMs?: number\r\n): Promise<types.ChatError | types.ChatResponse> {\r\n  // Workaround for https://github.com/esbuild-kit/tsx/issues/113\r\n  globalThis.__name = () => undefined\r\n\r\n  class TimeoutError extends Error {\r\n    readonly name: 'TimeoutError'\r\n\r\n    constructor(message) {\r\n      super(message)\r\n      this.name = 'TimeoutError'\r\n    }\r\n  }\r\n\r\n  /**\r\n    An error to be thrown when the request is aborted by AbortController.\r\n    DOMException is thrown instead of this Error when DOMException is available.\r\n  */\r\n  class AbortError extends Error {\r\n    constructor(message) {\r\n      super()\r\n      this.name = 'AbortError'\r\n      this.message = message\r\n    }\r\n  }\r\n\r\n  const BOM = [239, 187, 191]\r\n\r\n  let conversationId: string = body?.conversation_id\r\n  let messageId: string = body?.messages?.[0]?.id\r\n  let response = ''\r\n\r\n  try {\r\n    console.log('browserPostEventStream', url, accessToken, body)\r\n\r\n    let abortController: AbortController = null\r\n    if (timeoutMs) {\r\n      abortController = new AbortController()\r\n    }\r\n\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      body: JSON.stringify(body),\r\n      signal: abortController?.signal,\r\n      headers: {\r\n        accept: 'text/event-stream',\r\n        'x-openai-assistant-app-id': '',\r\n        authorization: `Bearer ${accessToken}`,\r\n        'content-type': 'application/json'\r\n      }\r\n    })\r\n\r\n    console.log('browserPostEventStream response', res)\r\n\r\n    if (!res.ok) {\r\n      return {\r\n        error: {\r\n          message: `ChatGPTAPI error ${res.status || res.statusText}`,\r\n          statusCode: res.status,\r\n          statusText: res.statusText\r\n        },\r\n        conversationId,\r\n        messageId\r\n      }\r\n    }\r\n\r\n    const responseP = new Promise<types.ChatResponse>(\r\n      async (resolve, reject) => {\r\n        function onMessage(data: string) {\r\n          if (data === '[DONE]') {\r\n            return resolve({\r\n              response,\r\n              conversationId,\r\n              messageId\r\n            })\r\n          }\r\n\r\n          try {\r\n            const convoResponseEvent: types.ConversationResponseEvent =\r\n              JSON.parse(data)\r\n            if (convoResponseEvent.conversation_id) {\r\n              conversationId = convoResponseEvent.conversation_id\r\n            }\r\n\r\n            if (convoResponseEvent.message?.id) {\r\n              messageId = convoResponseEvent.message.id\r\n            }\r\n\r\n            const partialResponse =\r\n              convoResponseEvent.message?.content?.parts?.[0]\r\n            if (partialResponse) {\r\n              response = partialResponse\r\n            }\r\n          } catch (err) {\r\n            console.warn('fetchSSE onMessage unexpected error', err)\r\n            reject(err)\r\n          }\r\n        }\r\n\r\n        const parser = createParser((event) => {\r\n          if (event.type === 'event') {\r\n            onMessage(event.data)\r\n          }\r\n        })\r\n\r\n        for await (const chunk of streamAsyncIterable(res.body)) {\r\n          const str = new TextDecoder().decode(chunk)\r\n          parser.feed(str)\r\n        }\r\n      }\r\n    )\r\n\r\n    if (timeoutMs) {\r\n      if (abortController) {\r\n        // This will be called when a timeout occurs in order for us to forcibly\r\n        // ensure that the underlying HTTP request is aborted.\r\n        ;(responseP as any).cancel = () => {\r\n          abortController.abort()\r\n        }\r\n      }\r\n\r\n      return await pTimeout(responseP, {\r\n        milliseconds: timeoutMs,\r\n        message: 'ChatGPT timed out waiting for response'\r\n      })\r\n    } else {\r\n      return await responseP\r\n    }\r\n  } catch (err) {\r\n    const errMessageL = err.toString().toLowerCase()\r\n\r\n    if (\r\n      response &&\r\n      (errMessageL === 'error: typeerror: terminated' ||\r\n        errMessageL === 'typeerror: terminated')\r\n    ) {\r\n      // OpenAI sometimes forcefully terminates the socket from their end before\r\n      // the HTTP request has resolved cleanly. In my testing, these cases tend to\r\n      // happen when OpenAI has already send the last `response`, so we can ignore\r\n      // the `fetch` error in this case.\r\n      return {\r\n        response,\r\n        conversationId,\r\n        messageId\r\n      }\r\n    }\r\n\r\n    return {\r\n      error: {\r\n        message: err.toString(),\r\n        statusCode: err.statusCode || err.status || err.response?.statusCode,\r\n        statusText: err.statusText || err.response?.statusText\r\n      },\r\n      conversationId,\r\n      messageId\r\n    }\r\n  }\r\n\r\n  async function* streamAsyncIterable<T>(stream: ReadableStream<T>) {\r\n    const reader = stream.getReader()\r\n    try {\r\n      while (true) {\r\n        const { done, value } = await reader.read()\r\n        if (done) {\r\n          return\r\n        }\r\n        yield value\r\n      }\r\n    } finally {\r\n      reader.releaseLock()\r\n    }\r\n  }\r\n\r\n  // @see https://github.com/rexxars/eventsource-parser\r\n  function createParser(onParse: EventSourceParseCallback): EventSourceParser {\r\n    // Processing state\r\n    let isFirstChunk: boolean\r\n    let buffer: string\r\n    let startingPosition: number\r\n    let startingFieldLength: number\r\n\r\n    // Event state\r\n    let eventId: string | undefined\r\n    let eventName: string | undefined\r\n    let data: string\r\n\r\n    reset()\r\n    return { feed, reset }\r\n\r\n    function reset(): void {\r\n      isFirstChunk = true\r\n      buffer = ''\r\n      startingPosition = 0\r\n      startingFieldLength = -1\r\n\r\n      eventId = undefined\r\n      eventName = undefined\r\n      data = ''\r\n    }\r\n\r\n    function feed(chunk: string): void {\r\n      buffer = buffer ? buffer + chunk : chunk\r\n\r\n      // Strip any UTF8 byte order mark (BOM) at the start of the stream.\r\n      // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\r\n      // always decoded as UTF8 as per the specification.\r\n      if (isFirstChunk && hasBom(buffer)) {\r\n        buffer = buffer.slice(BOM.length)\r\n      }\r\n\r\n      isFirstChunk = false\r\n\r\n      // Set up chunk-specific processing state\r\n      const length = buffer.length\r\n      let position = 0\r\n      let discardTrailingNewline = false\r\n\r\n      // Read the current buffer byte by byte\r\n      while (position < length) {\r\n        // EventSource allows for carriage return + line feed, which means we\r\n        // need to ignore a linefeed character if the previous character was a\r\n        // carriage return\r\n        // @todo refactor to reduce nesting, consider checking previous byte?\r\n        // @todo but consider multiple chunks etc\r\n        if (discardTrailingNewline) {\r\n          if (buffer[position] === '\\n') {\r\n            ++position\r\n          }\r\n          discardTrailingNewline = false\r\n        }\r\n\r\n        let lineLength = -1\r\n        let fieldLength = startingFieldLength\r\n        let character: string\r\n\r\n        for (\r\n          let index = startingPosition;\r\n          lineLength < 0 && index < length;\r\n          ++index\r\n        ) {\r\n          character = buffer[index]\r\n          if (character === ':' && fieldLength < 0) {\r\n            fieldLength = index - position\r\n          } else if (character === '\\r') {\r\n            discardTrailingNewline = true\r\n            lineLength = index - position\r\n          } else if (character === '\\n') {\r\n            lineLength = index - position\r\n          }\r\n        }\r\n\r\n        if (lineLength < 0) {\r\n          startingPosition = length - position\r\n          startingFieldLength = fieldLength\r\n          break\r\n        } else {\r\n          startingPosition = 0\r\n          startingFieldLength = -1\r\n        }\r\n\r\n        parseEventStreamLine(buffer, position, fieldLength, lineLength)\r\n\r\n        position += lineLength + 1\r\n      }\r\n\r\n      if (position === length) {\r\n        // If we consumed the entire buffer to read the event, reset the buffer\r\n        buffer = ''\r\n      } else if (position > 0) {\r\n        // If there are bytes left to process, set the buffer to the unprocessed\r\n        // portion of the buffer only\r\n        buffer = buffer.slice(position)\r\n      }\r\n    }\r\n\r\n    function parseEventStreamLine(\r\n      lineBuffer: string,\r\n      index: number,\r\n      fieldLength: number,\r\n      lineLength: number\r\n    ) {\r\n      if (lineLength === 0) {\r\n        // We reached the last line of this event\r\n        if (data.length > 0) {\r\n          onParse({\r\n            type: 'event',\r\n            id: eventId,\r\n            event: eventName || undefined,\r\n            data: data.slice(0, -1) // remove trailing newline\r\n          })\r\n\r\n          data = ''\r\n          eventId = undefined\r\n        }\r\n        eventName = undefined\r\n        return\r\n      }\r\n\r\n      const noValue = fieldLength < 0\r\n      const field = lineBuffer.slice(\r\n        index,\r\n        index + (noValue ? lineLength : fieldLength)\r\n      )\r\n      let step = 0\r\n\r\n      if (noValue) {\r\n        step = lineLength\r\n      } else if (lineBuffer[index + fieldLength + 1] === ' ') {\r\n        step = fieldLength + 2\r\n      } else {\r\n        step = fieldLength + 1\r\n      }\r\n\r\n      const position = index + step\r\n      const valueLength = lineLength - step\r\n      const value = lineBuffer\r\n        .slice(position, position + valueLength)\r\n        .toString()\r\n\r\n      if (field === 'data') {\r\n        data += value ? `${value}\\n` : '\\n'\r\n      } else if (field === 'event') {\r\n        eventName = value\r\n      } else if (field === 'id' && !value.includes('\\u0000')) {\r\n        eventId = value\r\n      } else if (field === 'retry') {\r\n        const retry = parseInt(value, 10)\r\n        if (!Number.isNaN(retry)) {\r\n          onParse({ type: 'reconnect-interval', value: retry })\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function hasBom(buffer: string) {\r\n    return BOM.every(\r\n      (charCode: number, index: number) => buffer.charCodeAt(index) === charCode\r\n    )\r\n  }\r\n\r\n  /**\r\n    TODO: Remove AbortError and just throw DOMException when targeting Node 18.\r\n   */\r\n  function getDOMException(errorMessage) {\r\n    return globalThis.DOMException === undefined\r\n      ? new AbortError(errorMessage)\r\n      : new DOMException(errorMessage)\r\n  }\r\n\r\n  /**\r\n    TODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\r\n   */\r\n  function getAbortedReason(signal) {\r\n    const reason =\r\n      signal.reason === undefined\r\n        ? getDOMException('This operation was aborted.')\r\n        : signal.reason\r\n\r\n    return reason instanceof Error ? reason : getDOMException(reason)\r\n  }\r\n\r\n  // @see https://github.com/sindresorhus/p-timeout\r\n  function pTimeout<ValueType, ReturnType = ValueType>(\r\n    promise: PromiseLike<ValueType>,\r\n    options: PTimeoutTypes.Options<ReturnType>\r\n  ): PTimeoutTypes.ClearablePromise<ValueType | ReturnType> {\r\n    const {\r\n      milliseconds,\r\n      fallback,\r\n      message,\r\n      customTimers = { setTimeout, clearTimeout }\r\n    } = options\r\n\r\n    let timer: number\r\n\r\n    const cancelablePromise = new Promise((resolve, reject) => {\r\n      if (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\r\n        throw new TypeError(\r\n          `Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``\r\n        )\r\n      }\r\n\r\n      if (milliseconds === Number.POSITIVE_INFINITY) {\r\n        resolve(promise)\r\n        return\r\n      }\r\n\r\n      if (options.signal) {\r\n        const { signal } = options\r\n        if (signal.aborted) {\r\n          reject(getAbortedReason(signal))\r\n        }\r\n\r\n        signal.addEventListener('abort', () => {\r\n          reject(getAbortedReason(signal))\r\n        })\r\n      }\r\n\r\n      timer = customTimers.setTimeout.call(\r\n        undefined,\r\n        () => {\r\n          if (fallback) {\r\n            try {\r\n              resolve(fallback())\r\n            } catch (error) {\r\n              reject(error)\r\n            }\r\n\r\n            return\r\n          }\r\n\r\n          const errorMessage =\r\n            typeof message === 'string'\r\n              ? message\r\n              : `Promise timed out after ${milliseconds} milliseconds`\r\n          const timeoutError =\r\n            message instanceof Error ? message : new TimeoutError(errorMessage)\r\n\r\n          if (typeof (promise as any).cancel === 'function') {\r\n            ;(promise as any).cancel()\r\n          }\r\n\r\n          reject(timeoutError)\r\n        },\r\n        milliseconds\r\n      )\r\n      ;(async () => {\r\n        try {\r\n          resolve(await promise)\r\n        } catch (error) {\r\n          reject(error)\r\n        } finally {\r\n          customTimers.clearTimeout.call(undefined, timer)\r\n        }\r\n      })()\r\n    })\r\n\r\n    ;(cancelablePromise as any).clear = () => {\r\n      customTimers.clearTimeout.call(undefined, timer)\r\n      timer = undefined\r\n    }\r\n\r\n    return cancelablePromise as any\r\n  }\r\n}\r\n","import delay from 'delay'\r\nimport type { Browser, HTTPRequest, HTTPResponse, Page } from 'puppeteer'\r\nimport { v4 as uuidv4 } from 'uuid'\r\n\r\nimport * as types from './types'\r\nimport { AChatGPTAPI } from './abstract-chatgpt-api'\r\nimport { getBrowser, getOpenAIAuth } from './openai-auth'\r\nimport {\r\n  browserPostEventStream,\r\n  isRelevantRequest,\r\n  markdownToText,\r\n  maximizePage,\r\n  minimizePage\r\n} from './utils'\r\n\r\nconst CHAT_PAGE_URL = 'https://chat.openai.com/chat'\r\n\r\nexport class ChatGPTAPIBrowser extends AChatGPTAPI {\r\n  protected _markdown: boolean\r\n  protected _debug: boolean\r\n  protected _minimize: boolean\r\n  protected _isGoogleLogin: boolean\r\n  protected _isMicrosoftLogin: boolean\r\n  protected _captchaToken: string\r\n  protected _nopechaKey: string\r\n  protected _accessToken: string\r\n\r\n  protected _email: string\r\n  protected _password: string\r\n\r\n  protected _executablePath: string\r\n  protected _browser: Browser\r\n  protected _page: Page\r\n  protected _proxyServer: string\r\n  protected _isRefreshing: boolean\r\n\r\n  /**\r\n   * Creates a new client for automating the ChatGPT webapp.\r\n   */\r\n  constructor(opts: {\r\n    email: string\r\n    password: string\r\n\r\n    /** @defaultValue `true` **/\r\n    markdown?: boolean\r\n\r\n    /** @defaultValue `false` **/\r\n    debug?: boolean\r\n\r\n    /** @defaultValue `false` **/\r\n    isGoogleLogin?: boolean\r\n\r\n    /** @defaultValue `false` **/\r\n    isMicrosoftLogin?: boolean\r\n\r\n    /** @defaultValue `true` **/\r\n    minimize?: boolean\r\n\r\n    /** @defaultValue `undefined` **/\r\n    captchaToken?: string\r\n\r\n    /** @defaultValue `undefined` **/\r\n    nopechaKey?: string\r\n\r\n    /** @defaultValue `undefined` **/\r\n    executablePath?: string\r\n\r\n    /** @defaultValue `undefined` **/\r\n    proxyServer?: string\r\n  }) {\r\n    super()\r\n\r\n    const {\r\n      email,\r\n      password,\r\n      markdown = true,\r\n      debug = false,\r\n      isGoogleLogin = false,\r\n      isMicrosoftLogin = false,\r\n      minimize = true,\r\n      captchaToken,\r\n      nopechaKey,\r\n      executablePath,\r\n      proxyServer\r\n    } = opts\r\n\r\n    this._email = email\r\n    this._password = password\r\n\r\n    this._markdown = !!markdown\r\n    this._debug = !!debug\r\n    this._isGoogleLogin = !!isGoogleLogin\r\n    this._isMicrosoftLogin = !!isMicrosoftLogin\r\n    this._minimize = !!minimize\r\n    this._captchaToken = captchaToken\r\n    this._nopechaKey = nopechaKey\r\n    this._executablePath = executablePath\r\n    this._proxyServer = proxyServer\r\n    this._isRefreshing = false\r\n\r\n    if (!this._email) {\r\n      const error = new types.ChatGPTError('ChatGPT invalid email')\r\n      error.statusCode = 401\r\n      throw error\r\n    }\r\n\r\n    if (!this._password) {\r\n      const error = new types.ChatGPTError('ChatGPT invalid password')\r\n      error.statusCode = 401\r\n      throw error\r\n    }\r\n  }\r\n\r\n  override async initSession() {\r\n    if (this._browser) {\r\n      await this.closeSession()\r\n    }\r\n\r\n    try {\r\n      this._browser = await getBrowser({\r\n        captchaToken: this._captchaToken,\r\n        nopechaKey: this._nopechaKey,\r\n        executablePath: this._executablePath,\r\n        proxyServer: this._proxyServer,\r\n        minimize: this._minimize\r\n      })\r\n      this._page =\r\n        (await this._browser.pages())[0] || (await this._browser.newPage())\r\n\r\n      if (this._proxyServer && this._proxyServer.includes('@')) {\r\n        try {\r\n          const proxyUsername = this._proxyServer.split('@')[0].split(':')[0]\r\n          const proxyPassword = this._proxyServer.split('@')[0].split(':')[1]\r\n\r\n          await this._page.authenticate({\r\n            username: proxyUsername,\r\n            password: proxyPassword\r\n          })\r\n        } catch (err) {\r\n          console.error(\r\n            `Proxy \"${this._proxyServer}\" throws an error at authenticating`,\r\n            err.toString()\r\n          )\r\n        }\r\n      }\r\n\r\n      // bypass annoying popup modals\r\n      this._page.evaluateOnNewDocument(() => {\r\n        window.localStorage.setItem('oai/apps/hasSeenOnboarding/chat', 'true')\r\n        window.localStorage.setItem(\r\n          'oai/apps/hasSeenReleaseAnnouncement/2022-12-15',\r\n          'true'\r\n        )\r\n      })\r\n\r\n      // await maximizePage(this._page)\r\n\r\n      this._page.on('request', this._onRequest.bind(this))\r\n      this._page.on('response', this._onResponse.bind(this))\r\n\r\n      // bypass cloudflare and login\r\n      const authInfo = await getOpenAIAuth({\r\n        email: this._email,\r\n        password: this._password,\r\n        browser: this._browser,\r\n        page: this._page,\r\n        isGoogleLogin: this._isGoogleLogin,\r\n        isMicrosoftLogin: this._isMicrosoftLogin\r\n      })\r\n\r\n      if (this._debug) {\r\n        console.log('chatgpt', this._email, 'auth', authInfo)\r\n      }\r\n    } catch (err) {\r\n      if (this._browser) {\r\n        await this._browser.close()\r\n      }\r\n\r\n      this._browser = null\r\n      this._page = null\r\n\r\n      throw err\r\n    }\r\n\r\n    if (!this.isChatPage || this._isGoogleLogin || this._isMicrosoftLogin) {\r\n      await this._page.goto(CHAT_PAGE_URL, {\r\n        waitUntil: 'networkidle2'\r\n      })\r\n    }\r\n\r\n    // dismiss welcome modal (and other modals)\r\n    do {\r\n      const modalSelector = '[data-headlessui-state=\"open\"]'\r\n\r\n      try {\r\n        if (!(await this._page.$(modalSelector))) {\r\n          break\r\n        }\r\n\r\n        await this._page.click(`${modalSelector} button:last-child`)\r\n      } catch (err) {\r\n        // \"next\" button not found in welcome modal\r\n        break\r\n      }\r\n\r\n      await delay(300)\r\n    } while (true)\r\n\r\n    if (!(await this.getIsAuthenticated())) {\r\n      throw new types.ChatGPTError('Failed to authenticate session')\r\n    }\r\n\r\n    if (this._minimize) {\r\n      return minimizePage(this._page)\r\n    }\r\n  }\r\n\r\n  _onRequest = (request: HTTPRequest) => {\r\n    const url = request.url()\r\n    if (!isRelevantRequest(url)) {\r\n      return\r\n    }\r\n\r\n    const method = request.method()\r\n    let body: any\r\n\r\n    if (method === 'POST') {\r\n      body = request.postData()\r\n\r\n      try {\r\n        body = JSON.parse(body)\r\n      } catch (_) {}\r\n\r\n      // if (url.endsWith('/conversation') && typeof body === 'object') {\r\n      //   const conversationBody: types.ConversationJSONBody = body\r\n      //   const conversationId = conversationBody.conversation_id\r\n      //   const parentMessageId = conversationBody.parent_message_id\r\n      //   const messageId = conversationBody.messages?.[0]?.id\r\n      //   const prompt = conversationBody.messages?.[0]?.content?.parts?.[0]\r\n\r\n      //   // TODO: store this info for the current sendMessage request\r\n      // }\r\n    }\r\n\r\n    if (this._debug) {\r\n      console.log('\\nrequest', {\r\n        url,\r\n        method,\r\n        headers: request.headers(),\r\n        body\r\n      })\r\n    }\r\n  }\r\n\r\n  _onResponse = async (response: HTTPResponse) => {\r\n    const request = response.request()\r\n\r\n    const url = response.url()\r\n    if (!isRelevantRequest(url)) {\r\n      return\r\n    }\r\n\r\n    const status = response.status()\r\n\r\n    let body: any\r\n    try {\r\n      body = await response.json()\r\n    } catch (_) {}\r\n\r\n    if (this._debug) {\r\n      console.log('\\nresponse', {\r\n        url,\r\n        ok: response.ok(),\r\n        status,\r\n        statusText: response.statusText(),\r\n        headers: response.headers(),\r\n        body,\r\n        request: {\r\n          method: request.method(),\r\n          headers: request.headers(),\r\n          body: request.postData()\r\n        }\r\n      })\r\n    }\r\n\r\n    if (url.endsWith('/conversation')) {\r\n      if (status === 403) {\r\n        console.log(`ChatGPT \"${this._email}\" error 403...`)\r\n        // this will be handled in the sendMessage error handler\r\n        // await this.refreshSession()\r\n      }\r\n    } else if (url.endsWith('api/auth/session')) {\r\n      if (status === 401) {\r\n        console.log(`ChatGPT \"${this._email}\" error 401...`)\r\n        // this will be handled in the sendMessage error handler\r\n        // await this.resetSession()\r\n      } else if (status === 403) {\r\n        console.log(`ChatGPT \"${this._email}\" error 403...`)\r\n        // this will be handled in the sendMessage error handler\r\n        // await this.refreshSession()\r\n      } else {\r\n        const session: types.SessionResult = body\r\n\r\n        if (session?.accessToken) {\r\n          this._accessToken = session.accessToken\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempts to handle 401 errors by re-authenticating.\r\n   */\r\n  async resetSession() {\r\n    console.log(`ChatGPT \"${this._email}\" resetSession...`)\r\n    try {\r\n      console.log('>>> closing session', this._email)\r\n      await this.closeSession()\r\n      console.log('<<< closing session', this._email)\r\n      await this.initSession()\r\n      console.log(`ChatGPT \"${this._email}\" refreshSession success`)\r\n    } catch (err) {\r\n      console.error(\r\n        `ChatGPT \"${this._email}\" resetSession error`,\r\n        err.toString()\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempts to handle 403 errors by refreshing the page.\r\n   */\r\n  async refreshSession() {\r\n    if (this._isRefreshing) {\r\n      return\r\n    }\r\n\r\n    this._isRefreshing = true\r\n    console.log(`ChatGPT \"${this._email}\" refreshSession...`)\r\n\r\n    try {\r\n      if (!this._minimize) {\r\n        await maximizePage(this._page)\r\n      }\r\n\r\n      await this._page.reload()\r\n\r\n      let response\r\n      const timeout = 120000 // 2 minutes in milliseconds\r\n\r\n      try {\r\n        // Wait for a response that includes the 'cf_clearance' cookie\r\n        response = await this._page.waitForResponse(\r\n          (response) => {\r\n            const cookie = response.headers()['set-cookie']\r\n            if (cookie?.includes('cf_clearance=')) {\r\n              const cfClearance = cookie\r\n                .split('cf_clearance=')?.[1]\r\n                ?.split(';')?.[0]\r\n              // console.log('Cloudflare Cookie:', cfClearance)\r\n              return true\r\n            }\r\n            return false\r\n          },\r\n          { timeout }\r\n        )\r\n      } catch (err) {\r\n        // Useful for when cloudflare cookie is still valid, to catch TimeoutError\r\n        response = !!(await this._getInputBox())\r\n      }\r\n\r\n      if (!response) {\r\n        throw new types.ChatGPTError('Could not fetch cf_clearance cookie')\r\n      }\r\n\r\n      if (this._minimize && this.isChatPage) {\r\n        await minimizePage(this._page)\r\n      }\r\n\r\n      console.log(`ChatGPT \"${this._email}\" refreshSession success`)\r\n    } catch (err) {\r\n      console.error(\r\n        `ChatGPT \"${this._email}\" error refreshing session`,\r\n        err.toString()\r\n      )\r\n    } finally {\r\n      this._isRefreshing = false\r\n    }\r\n  }\r\n\r\n  async getIsAuthenticated() {\r\n    try {\r\n      if (!this._accessToken) {\r\n        return false\r\n      }\r\n\r\n      const inputBox = await this._getInputBox()\r\n      return !!inputBox\r\n    } catch (err) {\r\n      // can happen when navigating during login\r\n      return false\r\n    }\r\n  }\r\n\r\n  // async getLastMessage(): Promise<string | null> {\r\n  //   const messages = await this.getMessages()\r\n\r\n  //   if (messages) {\r\n  //     return messages[messages.length - 1]\r\n  //   } else {\r\n  //     return null\r\n  //   }\r\n  // }\r\n\r\n  // async getPrompts(): Promise<string[]> {\r\n  //   // Get all prompts\r\n  //   const messages = await this._page.$$(\r\n  //     '.text-base:has(.whitespace-pre-wrap):not(:has(button:nth-child(2))) .whitespace-pre-wrap'\r\n  //   )\r\n\r\n  //   // Prompts are always plaintext\r\n  //   return Promise.all(messages.map((a) => a.evaluate((el) => el.textContent)))\r\n  // }\r\n\r\n  // async getMessages(): Promise<string[]> {\r\n  //   // Get all complete messages\r\n  //   // (in-progress messages that are being streamed back don't contain action buttons)\r\n  //   const messages = await this._page.$$(\r\n  //     '.text-base:has(.whitespace-pre-wrap):has(button:nth-child(2)) .whitespace-pre-wrap'\r\n  //   )\r\n\r\n  //   if (this._markdown) {\r\n  //     const htmlMessages = await Promise.all(\r\n  //       messages.map((a) => a.evaluate((el) => el.innerHTML))\r\n  //     )\r\n\r\n  //     const markdownMessages = htmlMessages.map((messageHtml) => {\r\n  //       // parse markdown from message HTML\r\n  //       messageHtml = messageHtml\r\n  //         .replaceAll('Copy code</button>', '</button>')\r\n  //         .replace(/Copy code\\s*<\\/button>/gim, '</button>')\r\n\r\n  //       return html2md(messageHtml, {\r\n  //         ignoreTags: [\r\n  //           'button',\r\n  //           'svg',\r\n  //           'style',\r\n  //           'form',\r\n  //           'noscript',\r\n  //           'script',\r\n  //           'meta',\r\n  //           'head'\r\n  //         ],\r\n  //         skipTags: ['button', 'svg']\r\n  //       })\r\n  //     })\r\n\r\n  //     return markdownMessages\r\n  //   } else {\r\n  //     // plaintext\r\n  //     const plaintextMessages = await Promise.all(\r\n  //       messages.map((a) => a.evaluate((el) => el.textContent))\r\n  //     )\r\n  //     return plaintextMessages\r\n  //   }\r\n  // }\r\n\r\n  override async sendMessage(\r\n    message: string,\r\n    opts: types.SendMessageOptions = {}\r\n  ): Promise<types.ChatResponse> {\r\n    const {\r\n      conversationId,\r\n      parentMessageId = uuidv4(),\r\n      messageId = uuidv4(),\r\n      action = 'next',\r\n      timeoutMs\r\n      // TODO\r\n      // onProgress\r\n    } = opts\r\n\r\n    const url = `https://chat.openai.com/backend-api/conversation`\r\n    const body: types.ConversationJSONBody = {\r\n      action,\r\n      messages: [\r\n        {\r\n          id: messageId,\r\n          role: 'user',\r\n          content: {\r\n            content_type: 'text',\r\n            parts: [message]\r\n          }\r\n        }\r\n      ],\r\n      model: 'text-davinci-002-render',\r\n      parent_message_id: parentMessageId\r\n    }\r\n\r\n    if (conversationId) {\r\n      body.conversation_id = conversationId\r\n    }\r\n\r\n    let result: types.ChatResponse | types.ChatError\r\n    let numTries = 0\r\n    let is401 = false\r\n\r\n    do {\r\n      if (is401 || !(await this.getIsAuthenticated())) {\r\n        console.log(`chatgpt re-authenticating ${this._email}`)\r\n\r\n        try {\r\n          await this.resetSession()\r\n        } catch (err) {\r\n          console.warn(\r\n            `chatgpt error re-authenticating ${this._email}`,\r\n            err.toString()\r\n          )\r\n        }\r\n\r\n        if (!(await this.getIsAuthenticated())) {\r\n          const error = new types.ChatGPTError('Not signed in')\r\n          error.statusCode = 401\r\n          throw error\r\n        }\r\n      }\r\n\r\n      try {\r\n        // console.log('>>> EVALUATE', url, this._accessToken, body)\r\n        result = await this._page.evaluate(\r\n          browserPostEventStream,\r\n          url,\r\n          this._accessToken,\r\n          body,\r\n          timeoutMs\r\n        )\r\n      } catch (err) {\r\n        // We catch all errors in `browserPostEventStream`, so this should really\r\n        // only happen if the page is refreshed or closed during its invocation.\r\n        // This may happen if we encounter a 401/403 and refresh the page in it's\r\n        // response handler or if the user has closed the page manually.\r\n\r\n        if (++numTries >= 2) {\r\n          const error = new types.ChatGPTError(err.toString())\r\n          error.statusCode = err.response?.statusCode\r\n          error.statusText = err.response?.statusText\r\n          throw error\r\n        }\r\n\r\n        console.warn('chatgpt sendMessage error; retrying...', err.toString())\r\n        await delay(5000)\r\n        continue\r\n      }\r\n\r\n      if ('error' in result) {\r\n        const error = new types.ChatGPTError(result.error.message)\r\n        error.statusCode = result.error.statusCode\r\n        error.statusText = result.error.statusText\r\n\r\n        ++numTries\r\n\r\n        if (error.statusCode === 401) {\r\n          is401 = true\r\n\r\n          if (numTries >= 2) {\r\n            throw error\r\n          } else {\r\n            continue\r\n          }\r\n        } else if (error.statusCode !== 403) {\r\n          throw error\r\n        } else if (numTries >= 2) {\r\n          await this.refreshSession()\r\n          throw error\r\n        } else {\r\n          await this.refreshSession()\r\n          await delay(1000)\r\n          result = null\r\n          continue\r\n        }\r\n      } else {\r\n        if (!this._markdown) {\r\n          result.response = markdownToText(result.response)\r\n        }\r\n\r\n        return result\r\n      }\r\n    } while (!result)\r\n\r\n    // console.log('<<< EVALUATE', result)\r\n\r\n    // const lastMessage = await this.getLastMessage()\r\n\r\n    // await inputBox.focus()\r\n    // const paragraphs = message.split('\\n')\r\n    // for (let i = 0; i < paragraphs.length; i++) {\r\n    //   await inputBox.type(paragraphs[i], { delay: 0 })\r\n    //   if (i < paragraphs.length - 1) {\r\n    //     await this._page.keyboard.down('Shift')\r\n    //     await inputBox.press('Enter')\r\n    //     await this._page.keyboard.up('Shift')\r\n    //   } else {\r\n    //     await inputBox.press('Enter')\r\n    //   }\r\n    // }\r\n\r\n    // const responseP = new Promise<string>(async (resolve, reject) => {\r\n    //   try {\r\n    //     do {\r\n    //       await delay(1000)\r\n\r\n    //       // TODO: this logic needs some work because we can have repeat messages...\r\n    //       const newLastMessage = await this.getLastMessage()\r\n    //       if (\r\n    //         newLastMessage &&\r\n    //         lastMessage?.toLowerCase() !== newLastMessage?.toLowerCase()\r\n    //       ) {\r\n    //         return resolve(newLastMessage)\r\n    //       }\r\n    //     } while (true)\r\n    //   } catch (err) {\r\n    //     return reject(err)\r\n    //   }\r\n    // })\r\n\r\n    // if (timeoutMs) {\r\n    //   return pTimeout(responseP, {\r\n    //     milliseconds: timeoutMs\r\n    //   })\r\n    // } else {\r\n    //   return responseP\r\n    // }\r\n  }\r\n\r\n  async resetThread() {\r\n    try {\r\n      await this._page.click('nav > a:nth-child(1)')\r\n    } catch (err) {\r\n      // ignore for now\r\n    }\r\n  }\r\n\r\n  override async closeSession() {\r\n    try {\r\n      if (this._page) {\r\n        this._page.off('request', this._onRequest.bind(this))\r\n        this._page.off('response', this._onResponse.bind(this))\r\n\r\n        await this._page.deleteCookie({\r\n          name: 'cf_clearance',\r\n          domain: '.chat.openai.com'\r\n        })\r\n\r\n        // TODO; test this\r\n        // const client = await this._page.target().createCDPSession()\r\n        // await client.send('Network.clearBrowserCookies')\r\n        // await client.send('Network.clearBrowserCache')\r\n\r\n        await this._page.close()\r\n      }\r\n    } catch (err) {\r\n      console.warn('closeSession error', err)\r\n    }\r\n\r\n    if (this._browser) {\r\n      try {\r\n        const pages = await this._browser.pages()\r\n        for (const page of pages) {\r\n          await page.close()\r\n        }\r\n      } catch (err) {\r\n        console.warn('closeSession error', err)\r\n      }\r\n\r\n      await this._browser.close()\r\n\r\n      const browserProcess = this._browser.process()\r\n      // Rule number 1 of zombie process hunting: double-tap\r\n      if (browserProcess) {\r\n        browserProcess.kill('SIGKILL')\r\n      }\r\n    }\r\n\r\n    this._page = null\r\n    this._browser = null\r\n    this._accessToken = null\r\n  }\r\n\r\n  protected async _getInputBox() {\r\n    try {\r\n      return await this._page.$('textarea')\r\n    } catch (err) {\r\n      return null\r\n    }\r\n  }\r\n\r\n  get isChatPage(): boolean {\r\n    try {\r\n      const url = this._page?.url().replace(/\\/$/, '')\r\n      return url === CHAT_PAGE_URL\r\n    } catch (err) {\r\n      return false\r\n    }\r\n  }\r\n}\r\n","import * as fs from 'node:fs'\nimport * as os from 'node:os'\nimport * as path from 'node:path'\nimport * as url from 'node:url'\n\nimport delay from 'delay'\nimport { TimeoutError } from 'p-timeout'\nimport { Browser, Page, Protocol, PuppeteerLaunchOptions } from 'puppeteer'\nimport puppeteer from 'puppeteer-extra'\nimport RecaptchaPlugin from 'puppeteer-extra-plugin-recaptcha'\nimport StealthPlugin from 'puppeteer-extra-plugin-stealth'\nimport random from 'random'\n\nimport * as types from './types'\nimport { minimizePage } from './utils'\n\npuppeteer.use(StealthPlugin())\n\nlet hasRecaptchaPlugin = false\nlet hasNopechaExtension = false\n\nconst __dirname = url.fileURLToPath(new URL('.', import.meta.url))\nconst DEFAULT_TIMEOUT_MS = 3 * 60 * 1000 // 3 minutes\n\n/**\n * Represents everything that's required to pass into `ChatGPTAPI` in order\n * to authenticate with the unofficial ChatGPT API.\n */\nexport type OpenAIAuth = {\n  userAgent: string\n  clearanceToken: string\n  sessionToken: string\n  cookies?: Record<string, Protocol.Network.Cookie>\n}\n\n/**\n * Bypasses OpenAI's use of Cloudflare to get the cookies required to use\n * ChatGPT. Uses Puppeteer with a stealth plugin under the hood.\n *\n * If you pass `email` and `password`, then it will log into the account and\n * include a `sessionToken` in the response.\n *\n * If you don't pass `email` and `password`, then it will just return a valid\n * `clearanceToken`.\n *\n * This can be useful because `clearanceToken` expires after ~2 hours, whereas\n * `sessionToken` generally lasts much longer. We recommend renewing your\n * `clearanceToken` every hour or so and creating a new instance of `ChatGPTAPI`\n * with your updated credentials.\n */\nexport async function getOpenAIAuth({\n  email,\n  password,\n  browser,\n  page,\n  timeoutMs = DEFAULT_TIMEOUT_MS,\n  isGoogleLogin = false,\n  isMicrosoftLogin = false,\n  captchaToken = process.env.CAPTCHA_TOKEN,\n  nopechaKey = process.env.NOPECHA_KEY,\n  executablePath,\n  proxyServer = process.env.PROXY_SERVER,\n  minimize = false\n}: {\n  email?: string\n  password?: string\n  browser?: Browser\n  page?: Page\n  timeoutMs?: number\n  isGoogleLogin?: boolean\n  isMicrosoftLogin?: boolean\n  minimize?: boolean\n  captchaToken?: string\n  nopechaKey?: string\n  executablePath?: string\n  proxyServer?: string\n}): Promise<OpenAIAuth> {\n  const origBrowser = browser\n  const origPage = page\n\n  try {\n    if (!browser) {\n      browser = await getBrowser({\n        captchaToken,\n        nopechaKey,\n        executablePath,\n        proxyServer,\n        timeoutMs\n      })\n    }\n\n    const userAgent = await browser.userAgent()\n    if (!page) {\n      page = (await browser.pages())[0] || (await browser.newPage())\n      page.setDefaultTimeout(timeoutMs)\n\n      if (minimize) {\n        await minimizePage(page)\n      }\n    }\n\n    await page.goto('https://chat.openai.com/auth/login', {\n      waitUntil: 'networkidle2'\n    })\n\n    // NOTE: this is where you may encounter a CAPTCHA\n    await checkForChatGPTAtCapacity(page, { timeoutMs })\n\n    if (hasRecaptchaPlugin) {\n      const captchas = await page.findRecaptchas()\n\n      if (captchas?.filtered?.length) {\n        console.log('solving captchas using 2captcha...')\n        const res = await page.solveRecaptchas()\n        console.log('captcha result', res)\n      }\n    }\n\n    // once we get to this point, the Cloudflare cookies should be available\n\n    // login as well (optional)\n    if (email && password) {\n      await waitForConditionOrAtCapacity(page, () =>\n        page.waitForSelector('#__next .btn-primary', { timeout: timeoutMs })\n      )\n      await delay(500)\n\n      // click login button and wait for navigation to finish\n      do {\n        await Promise.all([\n          page.waitForNavigation({\n            waitUntil: 'networkidle2',\n            timeout: timeoutMs\n          }),\n          page.click('#__next .btn-primary')\n        ])\n        await delay(500)\n      } while (page.url().endsWith('/auth/login'))\n\n      await checkForChatGPTAtCapacity(page, { timeoutMs })\n\n      let submitP: () => Promise<void>\n\n      if (isGoogleLogin) {\n        await page.waitForSelector('button[data-provider=\"google\"]', {\n          timeout: timeoutMs\n        })\n        await page.click('button[data-provider=\"google\"]')\n        await page.waitForSelector('input[type=\"email\"]')\n        await page.type('input[type=\"email\"]', email, { delay: 10 })\n        await Promise.all([\n          page.waitForNavigation(),\n          await page.keyboard.press('Enter')\n        ])\n        await page.waitForSelector('input[type=\"password\"]', { visible: true })\n        await page.type('input[type=\"password\"]', password, { delay: 10 })\n        submitP = () => page.keyboard.press('Enter')\n      } else if (isMicrosoftLogin) {\n        await page.click('button[data-provider=\"windowslive\"]')\n        await page.waitForSelector('input[type=\"email\"]')\n        await page.type('input[type=\"email\"]', email, { delay: 10 })\n        await Promise.all([\n          page.waitForNavigation(),\n          await page.keyboard.press('Enter')\n        ])\n        await delay(1500)\n        await page.waitForSelector('input[type=\"password\"]', { visible: true })\n        await page.type('input[type=\"password\"]', password, { delay: 10 })\n        submitP = () => page.keyboard.press('Enter')\n        await Promise.all([\n          page.waitForNavigation(),\n          await page.keyboard.press('Enter')\n        ])\n        await delay(1000)\n      } else {\n        await page.waitForSelector('#username')\n        await page.type('#username', email)\n        await delay(100)\n\n        // NOTE: this is where you may encounter a CAPTCHA\n        if (hasNopechaExtension) {\n          await waitForRecaptcha(page, { timeoutMs })\n        } else if (hasRecaptchaPlugin) {\n          console.log('solving captchas using 2captcha...')\n\n          // Add retries in case network is unstable\n          const retries = 3\n          for (let i = 0; i < retries; i++) {\n            try {\n              const res = await page.solveRecaptchas()\n              if (res.captchas?.length) {\n                console.log('captchas result', res)\n                break\n              } else {\n                console.log('no captchas found')\n                await delay(500)\n              }\n            } catch (e) {\n              console.log('captcha error', e)\n            }\n          }\n        }\n\n        await delay(2000)\n        const frame = page.mainFrame()\n        const submit = await page.waitForSelector('button[type=\"submit\"]', {\n          timeout: timeoutMs\n        })\n        await frame.focus('button[type=\"submit\"]')\n        await submit.focus()\n        await submit.click()\n        await page.waitForSelector('#password', { timeout: timeoutMs })\n        await page.type('#password', password, { delay: 10 })\n        submitP = () => page.click('button[type=\"submit\"]')\n      }\n\n      await Promise.all([\n        waitForConditionOrAtCapacity(page, () =>\n          page.waitForNavigation({\n            waitUntil: 'networkidle2',\n            timeout: timeoutMs\n          })\n        ),\n        submitP()\n      ])\n    } else {\n      await delay(2000)\n      await checkForChatGPTAtCapacity(page, { timeoutMs })\n    }\n\n    const pageCookies = await page.cookies()\n    const cookies = pageCookies.reduce(\n      (map, cookie) => ({ ...map, [cookie.name]: cookie }),\n      {}\n    )\n\n    const authInfo: OpenAIAuth = {\n      userAgent,\n      clearanceToken: cookies['cf_clearance']?.value,\n      sessionToken: cookies['__Secure-next-auth.session-token']?.value,\n      cookies\n    }\n\n    return authInfo\n  } catch (err) {\n    throw err\n  } finally {\n    if (origBrowser) {\n      if (page && page !== origPage) {\n        await page.close()\n      }\n    } else if (browser) {\n      await browser.close()\n    }\n\n    page = null\n    browser = null\n  }\n}\n\n/**\n * Launches a non-puppeteer instance of Chrome. Note that in my testing, I wasn't\n * able to use the built-in `puppeteer` version of Chromium because Cloudflare\n * recognizes it and blocks access.\n */\nexport async function getBrowser(\n  opts: PuppeteerLaunchOptions & {\n    captchaToken?: string\n    nopechaKey?: string\n    proxyServer?: string\n    minimize?: boolean\n    timeoutMs?: number\n  } = {}\n) {\n  const {\n    captchaToken = process.env.CAPTCHA_TOKEN,\n    nopechaKey = process.env.NOPECHA_KEY,\n    executablePath = defaultChromeExecutablePath(),\n    proxyServer = process.env.PROXY_SERVER,\n    minimize = false,\n    timeoutMs = DEFAULT_TIMEOUT_MS,\n    ...launchOptions\n  } = opts\n\n  if (captchaToken && !hasRecaptchaPlugin) {\n    hasRecaptchaPlugin = true\n    // console.log('use captcha', captchaToken)\n\n    puppeteer.use(\n      RecaptchaPlugin({\n        provider: {\n          id: '2captcha',\n          token: captchaToken\n        },\n        visualFeedback: true // colorize reCAPTCHAs (violet = detected, green = solved)\n      })\n    )\n  }\n\n  // https://peter.sh/experiments/chromium-command-line-switches/\n  const puppeteerArgs = [\n    '--no-sandbox',\n    '--disable-setuid-sandbox',\n    '--disable-infobars',\n    '--disable-dev-shm-usage',\n    '--disable-blink-features=AutomationControlled',\n    '--ignore-certificate-errors',\n    '--no-first-run',\n    '--no-service-autorun',\n    '--password-store=basic',\n    '--system-developer-mode',\n    // the following flags all try to reduce memory\n    // '--single-process',\n    '--mute-audio',\n    '--disable-default-apps',\n    '--no-zygote',\n    '--disable-accelerated-2d-canvas',\n    '--disable-web-security'\n    // '--disable-gpu'\n    // '--js-flags=\"--max-old-space-size=1024\"'\n  ]\n\n  /*   if (nopechaKey) {\n    const nopechaPath = path.join(\n      __dirname,\n      '..',\n      'third-party',\n      'nopecha-chrome-extension'\n    )\n    puppeteerArgs.push(`--load-extension=${nopechaPath}`)\n    hasNopechaExtension = true\n  } */\n\n  /*   if (proxyServer) {\n    const ipPort = proxyServer.includes('@')\n      ? proxyServer.split('@')[1]\n      : proxyServer\n    puppeteerArgs.push(`--proxy-server=${ipPort}`)\n  } */\n\n  const browser = await puppeteer.launch({\n    /*     headless: false,\n    // devtools: true,\n    args: puppeteerArgs,\n    ignoreDefaultArgs: ['--disable-extensions', '--enable-automation'],\n    ignoreHTTPSErrors: true,\n    executablePath,\n    ...launchOptions */\n  })\n\n  if (process.env.PROXY_VALIDATE_IP) {\n    const page = (await browser.pages())[0] || (await browser.newPage())\n    if (minimize) {\n      await minimizePage(page)\n    }\n\n    // Send a fetch request to https://ifconfig.co using page.evaluate() and\n    // verify that the IP matches\n    let ip: string\n    try {\n      const res = await page.evaluate(() => {\n        return fetch('https://ifconfig.co', {\n          headers: {\n            Accept: 'application/json'\n          }\n        }).then((res) => res.json())\n      })\n\n      ip = res?.ip\n    } catch (err) {\n      throw new Error(`Proxy IP validation failed: ${err.toString()}`)\n    }\n\n    if (!ip || ip !== process.env.PROXY_VALIDATE_IP) {\n      throw new Error(\n        `Proxy IP mismatch: ${ip} !== ${process.env.PROXY_VALIDATE_IP}`\n      )\n    }\n  }\n\n  await initializeNopechaExtension(browser, {\n    minimize,\n    nopechaKey,\n    timeoutMs\n  })\n\n  return browser\n}\n\nexport async function initializeNopechaExtension(\n  browser: Browser,\n  opts: {\n    minimize?: boolean\n    nopechaKey?: string\n    timeoutMs?: number\n  }\n) {\n  const { minimize = false, nopechaKey } = opts\n\n  if (hasNopechaExtension) {\n    const page = (await browser.pages())[0] || (await browser.newPage())\n    if (minimize) {\n      await minimizePage(page)\n    }\n\n    console.log('initializing nopecha extension with key', nopechaKey, '...')\n\n    // TODO: setting the nopecha extension key is really, really error prone...\n    for (let i = 0; i < 5; ++i) {\n      await page.goto(`https://nopecha.com/setup#${nopechaKey}`, {\n        waitUntil: 'networkidle0'\n      })\n      await delay(500)\n    }\n  }\n}\n\n/**\n * Gets the default path to chrome's executable for the current platform.\n */\nexport const defaultChromeExecutablePath = (): string => {\n  // return executablePath()\n\n  if (process.env.PUPPETEER_EXECUTABLE_PATH) {\n    return process.env.PUPPETEER_EXECUTABLE_PATH\n  }\n\n  switch (os.platform()) {\n    case 'win32':\n      return 'C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe'\n\n    case 'darwin':\n      return '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'\n\n    default: {\n      /**\n       * Since two (2) separate chrome releases exist on linux, we first do a\n       * check to ensure we're executing the right one.\n       */\n      const chromeExists = fs.existsSync('/usr/bin/google-chrome')\n\n      return chromeExists\n        ? '/usr/bin/google-chrome'\n        : '/usr/bin/google-chrome-stable'\n    }\n  }\n}\n\nasync function checkForChatGPTAtCapacity(\n  page: Page,\n  opts: {\n    timeoutMs?: number\n    pollingIntervalMs?: number\n    retries?: number\n  } = {}\n) {\n  const {\n    timeoutMs = 2 * 60 * 1000, // 2 minutes\n    pollingIntervalMs = 3000,\n    retries = 10\n  } = opts\n\n  // console.log('checkForChatGPTAtCapacity', page.url())\n  let isAtCapacity = false\n  let numTries = 0\n\n  do {\n    try {\n      await solveSimpleCaptchas(page)\n\n      const res = await page.$x(\"//div[contains(., 'ChatGPT is at capacity')]\")\n      isAtCapacity = !!res?.length\n\n      if (isAtCapacity) {\n        if (++numTries >= retries) {\n          break\n        }\n\n        // try refreshing the page if chatgpt is at capacity\n        await page.reload({\n          waitUntil: 'networkidle2',\n          timeout: timeoutMs\n        })\n\n        await delay(pollingIntervalMs)\n      }\n    } catch (err) {\n      // ignore errors likely due to navigation\n      ++numTries\n      break\n    }\n  } while (isAtCapacity)\n\n  if (isAtCapacity) {\n    const error = new types.ChatGPTError('ChatGPT is at capacity')\n    error.statusCode = 503\n    throw error\n  }\n}\n\nasync function waitForConditionOrAtCapacity(\n  page: Page,\n  condition: () => Promise<any>,\n  opts: {\n    pollingIntervalMs?: number\n  } = {}\n) {\n  const { pollingIntervalMs = 500 } = opts\n\n  return new Promise<void>((resolve, reject) => {\n    let resolved = false\n\n    async function waitForCapacityText() {\n      if (resolved) {\n        return\n      }\n\n      try {\n        await checkForChatGPTAtCapacity(page)\n\n        if (!resolved) {\n          setTimeout(waitForCapacityText, pollingIntervalMs)\n        }\n      } catch (err) {\n        if (!resolved) {\n          resolved = true\n          return reject(err)\n        }\n      }\n    }\n\n    condition()\n      .then(() => {\n        if (!resolved) {\n          resolved = true\n          resolve()\n        }\n      })\n      .catch((err) => {\n        if (!resolved) {\n          resolved = true\n          reject(err)\n        }\n      })\n\n    setTimeout(waitForCapacityText, pollingIntervalMs)\n  })\n}\n\nasync function solveSimpleCaptchas(page: Page) {\n  try {\n    const verifyYouAreHuman = await page.$('text=Verify you are human')\n    if (verifyYouAreHuman) {\n      await delay(2000)\n      await verifyYouAreHuman.click({\n        delay: random.int(5, 25)\n      })\n      await delay(1000)\n    }\n\n    const cloudflareButton = await page.$('.hcaptcha-box')\n    if (cloudflareButton) {\n      await delay(2000)\n      await cloudflareButton.click({\n        delay: random.int(5, 25)\n      })\n      await delay(1000)\n    }\n  } catch (err) {\n    // ignore errors\n  }\n}\n\nasync function waitForRecaptcha(\n  page: Page,\n  opts: {\n    pollingIntervalMs?: number\n    timeoutMs?: number\n  } = {}\n) {\n  await solveSimpleCaptchas(page)\n\n  if (!hasNopechaExtension) {\n    return\n  }\n\n  const { pollingIntervalMs = 100, timeoutMs } = opts\n  const captcha = await page.$('textarea#g-recaptcha-response')\n  const startTime = Date.now()\n\n  if (captcha) {\n    console.log('waiting to solve recaptcha...')\n\n    do {\n      try {\n        const captcha = await page.$('textarea#g-recaptcha-response')\n        if (!captcha) {\n          // the user may have gone past the page manually\n          console.log('captcha no longer found; continuing')\n          break\n        }\n\n        const value = (await captcha.evaluate((el) => el.value))?.trim()\n        if (value?.length) {\n          // recaptcha has been solved!\n          console.log('captcha solved; continuing')\n          break\n        }\n      } catch (err) {\n        // catch navigation-related page context errors\n      }\n\n      if (timeoutMs) {\n        const now = Date.now()\n        if (now - startTime >= timeoutMs) {\n          throw new TimeoutError('Timed out waiting to solve Recaptcha')\n        }\n      }\n\n      await delay(pollingIntervalMs)\n    } while (true)\n  }\n}\n"],"mappings":"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","names":["fetch","url","fetch","url","TimeoutError","_a","_b","_c","_d","createParser","streamAsyncIterable","pTimeout","url","message","fetch","delay","uuidv4","__dirname","res","captcha","url","delay","response","uuidv4"]}